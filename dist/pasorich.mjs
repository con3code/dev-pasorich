var img$2 = "data:image/png;base64,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";

var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMbSURBVHgB7Zz/selAFMe/7837HxXYWwEdiErogA7ogFeBUQG3gkcFdBAqEBXkZd3rjon84py1Z2U/M2cmI0J8d8+PPZIAdpgkFhdYG47wG3aISvYf4Qi2BDwX7CsTVxR/YIZmYoPEut/bzYz9RceGqdcOqEaE+wGIvo//RPXPsYoW7YTiGGfL/iWmIBgFueJd7QTBIoaQLd7tTBRHADfEu1oXDHBm4R7cguV8OQUM4BYBGOAsY5qlb2g2MRgMEATBZVspBSpRFP3Yfr/HcrnE4XCociiLC3MSoiDmjMfj+HQ6xa9gsVjEyQBVycaiyBVwOBzGr2a321URURS5JxqGYWyDyWTivoBJvIttoUNGySwsjdtlmFoL/9Dr9e5eW6/XmM/nVYN9Ia1WC41GAx8fH5jNZpfkdEVvd7tdbDabvMMbENK80GedOcqr1epuZoxGIyPFsU4eaZKsX3RMG0S46sBcV7idEVd0uWGCrBnNUSoVYasfKIUWiBifgcJpgEjdBSRj3IWzYhBH9s3ieDxW+v4byANf9xgoRkDvwkS8gDVFjAvnlgNZQTwr2HOge4Jpsgr5290g8lYu/ISAZOruwmTqLqACES4BFWqKd2EiRgV85TIu77NdWcopuIlfC9vGC0jElzFEfBlD5K2ysF/KEXG5maDgJr6MsY0XkAiHgK6380mXdxgVMCuAZwV6lzHqwjYEzCqT2m3yNUS5+BhIhENABbdRIOBnIBEvIBGjWVhfeptGYBZWIODLGCLehYl4AYlw3ObwUJWq75PjJN1zfKL/p0DA+H0iabSA3CLa5OUd6XfDaBY22b5/hPO56CkrgsuYB+7dNcZ0OjVaOhmNgVq8fr+PTqdzcWcTf/AUDZDet91uYRIOAQtV0T9CiiubwHekfTfGLl5AIt6FJZcxdcC7MBEvIJFfoCPu8SFP8LQOfgYS4RDwALc5gACHgGu4zQYEOAT8hNuImAA7GHiQzgssBBGuJPIXbrKBIPRoujDrbk1BEAHcEm8CgeiTckG8EIKRLqIWT4EJjqVcFj18ubQ09L9LSzA+M/A/pHd1a8TRIUYAAAAASUVORK5CYII=";

var en$1 = {
	"pasorich.entry.name": "PaSoRich 1.0d",
	"pasorich.entry.description": "Description of this extension"
};
var ja$1 = {
	"pasorich.entry.name": "パソリッチ 1.0d",
	"pasorich.entry.description": "拡張機能の説明"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"pasorich.entry.name": "ぱそりっち 1.0d",
	"pasorich.entry.description": "かくちょうきのうのせつめい"
}
};

/**
 * This is an extension for Xcratch.
 */

/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'pasorich.entry.name',
      default: 'PaSoRich',
      description: 'name of the extension'
    });
  },
  extensionId: 'pasorich',
  extensionURL: 'https://con3code.github.io/dev-pasorich/dist/pasorich.mjs',
  collaborator: 'con3code',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      defaultMessage: 'an extension for Xcratch',
      description: 'Description for this extension',
      id: 'pasorich.entry.description'
    });
  },
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  helpLink: 'https://con3.com/sc2scratch/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _typeof$1(o) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$1(o);
}

function _toPrimitive(input, hint) {
  if (_typeof$1(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof = {exports: {}};

(function (module) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof);

(function (module) {
  var _typeof$1 = _typeof.exports["default"];
  function _regeneratorRuntime() {

    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function define(t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == _typeof$1(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function value(t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw new Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(_typeof$1(e) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function stop() {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function complete(t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function finish(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      "catch": function _catch(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntime$1.exports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);
  }
  _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }

    /** @type {RGBObject} */
  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }

    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */
  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }
      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }

    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }

    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */
  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }

    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */
  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }

    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */
  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }

    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }

    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */
  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b);

      // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
      var h = 0;
      var s = 0;
      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    }

    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */
  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);
  return Color;
}();
var color = Color$1;

var Color = color;

/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */
var Cast = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck(this, Cast);
  }
  _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }
        return value;
      }
      var n = Number(value);
      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }
      return n;
    }

    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */
  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }
      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        }
        // All other strings treated as true.
        return true;
      }
      // Coerce other values and numbers.
      return Boolean(value);
    }

    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */
  }, {
    key: "toString",
    value: function toString(value) {
      return String(value);
    }

    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }

    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;
      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value);

        // If the color wasn't *actually* a hex color, cast to black
        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }
      return color;
    }

    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */
  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }

    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */
  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);
      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }
      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = String(v1).toLowerCase();
        var s2 = String(v2).toLowerCase();
        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }
        return 0;
      }
      // Handle the special case of Infinity
      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      }
      // Compare as numbers.
      return n1 - n2;
    }

    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */
  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        }
        // True if it's "round" (e.g., 2.0 and 2).
        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }
      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }

    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */
  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }
        if (index === 'last') {
          if (length > 0) {
            return length;
          }
          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }
          return Cast.LIST_INVALID;
        }
      }
      index = Math.floor(Cast.toNumber(index));
      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }
      return index;
    }
  }]);
  return Cast;
}();
var cast = Cast;

var en = {
	"pasorich.name": "PaSoRich",
	"pasorich.doIt": "do it [SCRIPT]"
};
var ja = {
	"pasorich.name": "PaSoRich",
	"pasorich.PaSoRich": "パソリッチ",
	"pasorich.push2Connect": "押して接続",
	"pasorich.Connect": "接続",
	"pasorich.readPasori": "パソリ読み取り",
	"pasorich.getIdm": "IDm",
	"pasorich.getHashedIdm": "HexIDm",
	"pasorich.resetIdm": "IDmリセット",
	"pasorich.getReadingFlag": "読取中",
	"pasorich.getWaitingFlag": "待機中",
	"pasorich.readingDone": "読み取り完了",
	"pasorich.ConnectReading": "読取中...",
	"pasorich.ConnectConnected": "接続完了...",
	"pasorich.ConnectConnecting": "接続中...",
	"pasorich.ConnectSuccess": "接続成功...",
	"pasorich.ConnectFailure": "接続失敗..."
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"pasorich.name": "PaSoRich",
	"pasorich.PaSoRich": "ぱそりっち",
	"pasorich.push2Connect": "おしてせつぞく",
	"pasorich.Connect": "せつぞく",
	"pasorich.readPasori": "パソリよみとり",
	"pasorich.getIdm": "IDm",
	"pasorich.getHashedIdm": "HexIDm",
	"pasorich.resetIdm": "IDmリセット",
	"pasorich.getReadingFlag": "よみとりちゅう",
	"pasorich.getWaitingFlag": "たいきちゅう",
	"pasorich.readingDone": "よみとりかんりょう",
	"pasorich.ConnectReading": "よみとりちゅう...",
	"pasorich.ConnectConnected": "せつぞくかんりょう...",
	"pasorich.ConnectConnecting": "せつぞくちゅう...",
	"pasorich.ConnectSuccess": "せつぞくせいこう...",
	"pasorich.ConnectFailure": "せつぞくしっぱい..."
}
};

var img = "data:image/png;base64,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";

// Variables
var pasoriDevice;
var idmNum = '';
var deviceFlag = false;
var readingFlag = false;
var connectingCount = 0;
var intvalTimeShort = 12;
var PaSoRichVersion = "PaSoRich 1.0d";

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.defaultMessage;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = 'pasorich';

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = 'https://con3code.github.io/dev-pasorich/dist/pasorich.mjs';

/**
 * Scratch 3.0 blocks for example of Xcratch.
 */
var Scratch3Pasorich = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for PaSoRich.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function Scratch3Pasorich(runtime) {
    _classCallCheck(this, Scratch3Pasorich);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }
    if (pasoriDevice !== undefined) {
      if (pasoriDevice.opened) {
        pasoriDevice.close();
        //console.log("- pasoriDevice:" + pasoriDevice);
      }
    }
    navigator.usb.getDevices().then(function (devices) {
      //console.log(devices);
      devices.map(function (selectedDevice) {
        pasoriDevice = selectedDevice;
        pasoriDevice.open().then(function () {
          return pasoriDevice.selectConfiguration(1);
        }).then(function () {
          return pasoriDevice.claimInterface(0);
        }).then(function () {
          deviceFlag = true;
        }).catch(function (error) {
          deviceFlag = false;
          console.log(error);
        });
      });
    }).catch(function (error) {
      deviceFlag = false;
      console.log(error);
    });
    if (pasoriDevice == null) {
      var reqdevicePromise = navigator.usb.requestDevice({
        filters: [{
          vendorId: 0x054c
        }]
      });
      while (reqdevicePromise == undefined) {
        sleep(intvalTimeShort);
      }
      if (reqdevicePromise !== undefined) {
        reqdevicePromise.then(function (selectedDevice) {
          pasoriDevice = selectedDevice;
          return pasoriDevice.open();
        }).then(function () {
          return pasoriDevice.selectConfiguration(1);
        }).then(function () {
          return pasoriDevice.claimInterface(0);
        }).then(function () {
          deviceFlag = true;
          sleep(intvalTimeShort);
          return session(pasoriDevice);
        }).catch(function (error) {
          deviceFlag = false;
          console.log(error);
        });
      }
    }
    console.log(PaSoRichVersion);
  }
  _createClass(Scratch3Pasorich, [{
    key: "doIt",
    value: function doIt(args) {
      var func = new Function("return (".concat(cast.toString(args.SCRIPT), ")"));
      var result = func.call(this);
      console.log(result);
      return result;
    }
  }, {
    key: "openPasori",
    value: function openPasori() {
      var connectMessage = formatMessage({
        id: 'pasorich.ConnectConnecting',
        default: 'Connecting...',
        description: 'ConnectConnecting'
      });
      if (deviceFlag || pasoriDevice !== undefined && pasoriDevice !== null) {
        connectingCount = 0;
        deviceFlag = true;
        isConnect = formatMessage({
          id: 'pasorich.ConnectConnected',
          default: 'Connected...',
          description: 'ConnectConnected'
        });
        return isConnect;
      }
      if (connectingCount >= 1) {
        return connectMessage;
      }
      connectingCount += 1;
      isConnect = connectMessage;
      if (connectingCount > 1) {
        return isConnect;
      }
      navigator.usb.requestDevice({
        filters: [{
          vendorId: 0x054c
        }]
      }).then(function (selectedDevice) {
        pasoriDevice = selectedDevice;
        return pasoriDevice.open();
      }).then(function () {
        return pasoriDevice.selectConfiguration(1);
      }).then(function () {
        deviceFlag = true;
        isConnect = formatMessage({
          id: 'pasorich.ConnectConnected',
          default: 'Connected...',
          description: 'ConnectConnected'
        });
        return pasoriDevice.claimInterface(0);
      }).catch(function (error) {
        pasoriDevice = null;
        deviceFlag = false;
        console.error(error);
      });
      return isConnect;
    }
  }, {
    key: "readPasori",
    value: function readPasori() {
      if (readingFlag) {
        return;
      }
      readingFlag = true;
      if (deviceFlag) {
        if (pasoriDevice.opened && pasoriDevice !== null) {
          sleep(intvalTimeShort);
          return session(pasoriDevice);
        } else {
          navigator.usb.getDevices().then(function (devices) {
            return Promise.all(devices.map(setupDevice));
          }).catch(function (error) {
            deviceFlag = false;
            readingFlag = false;
            console.log(error);
          });
        }
      } else {
        navigator.usb.requestDevice({
          filters: [{
            vendorId: 0x054c
          }]
        }).then(setupDevice).catch(function (error) {
          deviceFlag = false;
          readingFlag = false;
          console.log(error);
        });
      }
    }
  }, {
    key: "getIdm",
    value: function getIdm() {
      return idmNum;
    }
  }, {
    key: "resetIdm",
    value: function resetIdm() {
      idmNum = '';
      readingFlag = false;
      return;
    }

    /**
     * Setup format-message for this extension.
     */
  }, {
    key: "setupTranslations",
    value: function setupTranslations() {
      var localeSetup = formatMessage.setup();
      if (localeSetup && localeSetup.translations[localeSetup.locale]) {
        Object.assign(localeSetup.translations[localeSetup.locale],
        // eslint-disable-next-line no-use-before-define
        extensionTranslations[localeSetup.locale]);
      }
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
  }, {
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: Scratch3Pasorich.EXTENSION_ID,
        name: Scratch3Pasorich.EXTENSION_NAME,
        extensionURL: Scratch3Pasorich.extensionURL,
        blockIconURI: img,
        showStatusButton: false,
        blocks: [{
          opcode: 'openPasori',
          text: formatMessage({
            id: 'pasorich.Connect',
            default: 'Connect',
            description: 'openPasori'
          }),
          blockType: blockType.REPORTER
        }, '---', {
          opcode: 'readPasori',
          text: formatMessage({
            id: 'pasorich.readPasori',
            default: 'read PaSoRi',
            description: 'readPasori'
          }),
          blockType: blockType.COMMAND
        }, '---', {
          opcode: 'getIdm',
          text: formatMessage({
            id: 'pasorich.getIdm',
            default: 'IDm',
            description: 'getIdm'
          }),
          blockType: blockType.REPORTER
        }, {
          opcode: 'resetIdm',
          text: formatMessage({
            id: 'pasorich.resetIdm',
            default: 'reset IDm',
            description: 'reset IDm and Variables'
          }),
          blockType: blockType.COMMAND
        }],
        menus: {}
      };
    }
  }], [{
    key: "EXTENSION_NAME",
    get:
    /**
     * @return {string} - the name of this extension.
     */
    function get() {
      return formatMessage({
        id: 'pasorich.name',
        default: 'PaSoRich',
        description: 'name of the extension'
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }
  }]);
  return Scratch3Pasorich;
}();
var isConnect = formatMessage({
  id: 'pasorich.push2Connect',
  default: 'Push to Connect.',
  description: 'push2Connect'
});
function hexString(textStr) {
  var byteArray = new Uint8Array(textStr);
  var hexCodes = _toConsumableArray(byteArray).map(function (value) {
    var hexCode = value.toString(16);
    var paddedHexCode = hexCode.padStart(2, '0');
    return paddedHexCode;
  });
  return hexCodes.join('');
}
function sleep(msec) {
  return new Promise(function (resolve) {
    return setTimeout(function () {
      resolve();
    }, msec);
  });
}
function send(_x, _x2) {
  return _send.apply(this, arguments);
}
function _send() {
  _send = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(device, data) {
    var uint8a;
    return regenerator.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          uint8a = new Uint8Array(data);
          _context.next = 3;
          return device.transferOut(2, uint8a);
        case 3:
          _context.next = 5;
          return sleep(10);
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _send.apply(this, arguments);
}
function receive(_x3, _x4) {
  return _receive.apply(this, arguments);
}
function _receive() {
  _receive = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(device, len) {
    var data, arr, i;
    return regenerator.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return device.transferIn(1, len);
        case 2:
          data = _context2.sent;
          _context2.next = 5;
          return sleep(10);
        case 5:
          arr = [];
          for (i = data.data.byteOffset; i < data.data.byteLength; i++) {
            arr.push(data.data.getUint8(i));
          }
          return _context2.abrupt("return", arr);
        case 8:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _receive.apply(this, arguments);
}
function setupDevice(_x5) {
  return _setupDevice.apply(this, arguments);
}
function _setupDevice() {
  _setupDevice = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(selectedDevice) {
    return regenerator.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          pasoriDevice = selectedDevice;
          _context3.next = 3;
          return pasoriDevice.open();
        case 3:
          _context3.next = 5;
          return pasoriDevice.selectConfiguration(1);
        case 5:
          _context3.next = 7;
          return pasoriDevice.claimInterface(0);
        case 7:
          deviceFlag = true;
          sleep(intvalTimeShort);
          return _context3.abrupt("return", session(pasoriDevice));
        case 10:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _setupDevice.apply(this, arguments);
}
function session(_x6) {
  return _session.apply(this, arguments);
}
function _session() {
  _session = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(device) {
    var idm, idmStr, i;
    return regenerator.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return send(device, [0x00, 0x00, 0xff, 0x00, 0xff, 0x00]);
        case 2:
          _context4.next = 4;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0x00, 0xfd, 0xd6, 0x2a, 0x01, 0xff, 0x00]);
        case 4:
          _context4.next = 6;
          return receive(device, 6);
        case 6:
          _context4.next = 8;
          return receive(device, 13);
        case 8:
          _context4.next = 10;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0x00, 0xfd, 0xd6, 0x06, 0x00, 0x24, 0x00]);
        case 10:
          _context4.next = 12;
          return receive(device, 6);
        case 12:
          _context4.next = 14;
          return receive(device, 13);
        case 14:
          _context4.next = 16;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0x00, 0xfd, 0xd6, 0x06, 0x00, 0x24, 0x00]);
        case 16:
          _context4.next = 18;
          return receive(device, 6);
        case 18:
          _context4.next = 20;
          return receive(device, 13);
        case 20:
          _context4.next = 22;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x06, 0x00, 0xfa, 0xd6, 0x00, 0x01, 0x01, 0x0f, 0x01, 0x18, 0x00]);
        case 22:
          _context4.next = 24;
          return receive(device, 6);
        case 24:
          _context4.next = 26;
          return receive(device, 13);
        case 26:
          _context4.next = 28;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x28, 0x00, 0xd8, 0xd6, 0x02, 0x00, 0x18, 0x01, 0x01, 0x02, 0x01, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x08, 0x08, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x0e, 0x04, 0x0f, 0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x06, 0x4b, 0x00]);
        case 28:
          _context4.next = 30;
          return receive(device, 6);
        case 30:
          _context4.next = 32;
          return receive(device, 13);
        case 32:
          _context4.next = 34;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x04, 0x00, 0xfc, 0xd6, 0x02, 0x00, 0x18, 0x10, 0x00]);
        case 34:
          _context4.next = 36;
          return receive(device, 6);
        case 36:
          _context4.next = 38;
          return receive(device, 13);
        case 38:
          _context4.next = 40;
          return send(device, [0x00, 0x00, 0xff, 0xff, 0xff, 0x0a, 0x00, 0xf6, 0xd6, 0x04, 0x6e, 0x00, 0x06, 0x00, 0xff, 0xff, 0x01, 0x00, 0xb3, 0x00]);
        case 40:
          _context4.next = 42;
          return receive(device, 6);
        case 42:
          _context4.next = 44;
          return receive(device, 37);
        case 44:
          idm = _context4.sent.slice(17, 25);
          if (!(idm.length > 0)) {
            _context4.next = 55;
            break;
          }
          idmStr = '';
          for (i = 0; i < idm.length; i++) {
            if (idm[i] < 16) {
              idmStr += '0';
            }
            idmStr += idm[i].toString(16);
          }

          //console.log("IDm: " + idmStr);
          idmNum = JSON.parse(JSON.stringify(idmStr));
          if (!(!crypto || !crypto.subtle)) {
            _context4.next = 51;
            break;
          }
          throw Error("crypto.subtle is not supported.");
        case 51:
          crypto.subtle.digest('SHA-256', new TextEncoder().encode(idmNum)).then(function (idmNumStr) {
            hexString(idmNumStr);
            //console.log("HashedIDm: " + idmNumSha256);
          });
          readingFlag = false;
          _context4.next = 58;
          break;
        case 55:
          idmNum = '';
          readingFlag = false;
        case 58:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _session.apply(this, arguments);
}

export { Scratch3Pasorich as blockClass, entry };
